/*

  $Id$

  G N O K I I

  A Linux/Unix toolset and driver for Nokia mobile phones.

  This file is part of gnokii.

  Gnokii is free software; you can redistribute it and/or modify
  it under the terms of the GNU General Public License as published by
  the Free Software Foundation; either version 2 of the License, or
  (at your option) any later version.

  Gnokii is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.

  You should have received a copy of the GNU General Public License
  along with gnokii; if not, write to the Free Software
  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

  Copyright (C) 1999-2000  Hugh Blemings & Pavel Janík ml.

*/

%{
#include <string.h>

#include "gsm-common.h"
#include "gsm-filetypes.h"

#define YY_DECL int yylex(char *type, char *text, char *desc, char *time, char *alarm, char *todo_priority, int lexnumber)
int veventcounter = 0, vtodocounter = 0;

%}

%x vcalendar
%x vevent
%x vtodo
%x category
%x summary
%x todosummary
%x description
%x ttime
%x aalarm
%x tpriority
%option noyywrap
%option nounput

%%

BEGIN:VCALENDAR				BEGIN(vcalendar);

<vcalendar>BEGIN:VEVENT			++veventcounter; BEGIN(vevent);

<vcalendar>BEGIN:VTODO			++vtodocounter; BEGIN(vtodo);

<vtodo>SUMMARY:				BEGIN(todosummary);

<todosummary>[[:alnum:] ]+		{
						if (vtodocounter == lexnumber)
							snprintf(text, 256, "%s", yytext);
						BEGIN(vtodo);
					}

<vtodo>PRIORITY:			BEGIN(tpriority);

<tpriority>[0-9]{1}			{
						if (vtodocounter == lexnumber)
							snprintf(todo_priority, 1, "%s", yytext);
						BEGIN(vtodo);
					}

<vevent>CATEGORIES:			BEGIN(category);

<category>[[:alnum:] ]+			{
						if (veventcounter == lexnumber)
							snprintf(type, 21, "%s", yytext);
						BEGIN(vevent);
					}

<vevent>SUMMARY:			BEGIN(summary);

<summary>[[:alnum:] ]+			{
						if (veventcounter == lexnumber)
							snprintf(text, 256, "%s", yytext);
						BEGIN(vevent);
					}

<vevent>DESCRIPTION:			BEGIN(description);

<description>[[:alnum:] ]+		{
						if (veventcounter == lexnumber)
							snprintf(desc, 256, "%s", yytext);
						BEGIN(vevent);
					}

<vevent>DTSTART:			BEGIN(ttime);

<ttime>[0-9]{8}T[0-9]{6}		{
						if (veventcounter == lexnumber)
							snprintf(time, 16, "%s", yytext);
						BEGIN(vevent);
					}

<vevent>AALARM:				BEGIN(aalarm);

<aalarm>[0-9]{8}T[0-9]{6}		{
						if (veventcounter == lexnumber)
							strncpy(alarm, yytext, 16);
						BEGIN(vevent);
					}


<vevent>END:VEVENT			BEGIN(vcalendar);

<vcalendar>END:VCALENDAR		BEGIN(0);
<*>.|\n
<*><<EOF>>				{
	                                        if (((lexnumber > 0) && (lexnumber < veventcounter + 1)) ||
						    ((lexnumber > 0) && (lexnumber < vtodocounter + 1)))
						{
							return 0;
						}
						fprintf(stderr, "Error: Invalid calendar note number!\n");
						return -1;
					}

%%

/**
* vcal_time_get
*
* Fills vCalendar time string into gn_timestamp structure
*
* in:
*   dt:  datetime structure
*   time:  string in format yyyymmddThhmmss
* out:
*   <>0 if error
*/
int vcal_time_get(gn_timestamp *dt, char *time)
{
	char year[5] = "", month[3] = "", day[3] = "", hour[3] = "", minute[3] = "", second[3] = "";
	dt->year = dt->month = dt->day = dt->hour = dt->minute = dt->second = dt->timezone = 0;

	snprintf(year, 4, "%s", time);
	snprintf(month, 2, "%s", time + 4);
	snprintf(day, 2, "%s", time + 6);
	snprintf(hour, 2, "%s", time + 9);
	snprintf(minute, 2, "%s", time + 11);
	snprintf(second, 2, "%s", time + 13);

	/* FIXME: Should check ranges... */
	dt->year = atoi(year);
	dt->month = atoi(month);
	dt->day = atoi(day);
	dt->hour = atoi(hour);
	dt->minute = atoi(minute);
	dt->second = atoi(second);
	/* FIXME */
	dt->timezone = 0;

	return 0;
}

/**
* gn_calnote_fill
*
* Fills calendar data from strings into calendar note
*
* in:
*   note:  calendar note structure
*   type:  type of calendar note
*   text:  text or phonenumber
*   time:  string in format yyyymmddThhmmss
*   alarm: dito
* out:
*   <>0 if error
*/
int gn_calnote_fill(gn_calnote *note, char *type, char *text,
		    char *desc, char *time, char *alarm)
{

	vcal_time_get(&note->time, time);
	vcal_time_get(&note->alarm.timestamp, alarm);

	note->location = 0;

	snprintf(note->text, 256, "%s", text);
	snprintf(note->phone_number, 0, "%s", "");

	/* FIXME: Handle additional strings, maybee from configuration file */
	if (!strcmp(type, "PHONE CALL")) {
		snprintf(note->phone_number, 48, "%s", text);
		if (desc[0] != 0) snprintf(note->text, 256, "%s", desc);
		note->type = GN_CALNOTE_CALL;
	} else if (!strcmp(type, "MEETING"))
		note->type = GN_CALNOTE_MEETING;
	else if (!strcmp(type, "SPECIAL OCASSION"))
		note->type = GN_CALNOTE_BIRTHDAY;
	else
		note->type = GN_CALNOTE_REMINDER;

	return 0;
}

/**
* gn_vcal_file_event_read
*
* Reads vCalendar file and parses VEVENT entries
*
* in:
*   FileName: name of vCalendar file
*   cnote:  pointer to calendar note
*   number:  number in file of calendar note to read
* out:
*   <>0 if error
*/
int gn_vcal_file_event_read(char *filename, gn_calnote *cnote, int number)
{
	FILE *file;
	char type[21] = "", text[257] = "", desc[257] = "", time[16] = "", alarm[16] = "", todo_priority[2] = "";

	file = fopen(filename, "r");
	if (!file) {
		fprintf(stderr, _("File cannot be opened!\n"));
		return -1;
	}

	yyin = file;

	if (yylex(type, text, desc, time, alarm, todo_priority, number)) {
		fprintf(stderr, _("Error parsing vCalendar file!\n"));
		return -1;
	}
	gn_calnote_fill(cnote, type, text, desc, time, alarm);

	fclose(file);
	return 0;
}

/**
* gn_todo_fill
*
* Fills todo data from strings into ToDo
*
* in:
*   note:  todo structure
*   text:  text or phonenumber
*   priority:  GN_TODO_HIGH (highest), GN_TODO_MEDIUM, GN_TODO_LOW (lowest)
* out:
*   <>0 if error
*/
int gn_todo_fill(gn_todo *todonote, char *text, char *todo_priority)
{
	todonote->location = 0;
	snprintf(todonote->text, GN_TODO_MAX_LENGTH, "%s", text);
	todonote->priority = GN_TODO_MEDIUM;
	if (todo_priority) todonote->priority = atoi(todo_priority);
	return 0;
}

/**
* gn_vcal_file_todo_read
*
* Reads vCalendar file and parses VTODO entries
*
* in:
*   FileName: name of vCalendar file
*   ctodo:  pointer to calendar note
*   number:  number in file of calendar note to read
* out:
*   <>0 if error
*/
int gn_vcal_file_todo_read(char *filename, gn_todo *ctodo, int number)
{
	FILE *file;
	char type[21] = "", text[258] = "", desc[258] = "", time[16] = "", alarm[16] = "", todo_priority[3] = "";

	file = fopen(filename, "r");
	if (!file) {
		fprintf(stderr, _("File cannot be opened!\n"));
		return -1;
	}

	yyin = file;

	if (yylex(type, text, desc, time, alarm, todo_priority, number)) {
		fprintf(stderr, _("Error parsing vCalendar file!\n"));
		return -1;
	}
	gn_todo_fill(ctodo, text, todo_priority);

	fclose(file);
	return 0;
}
